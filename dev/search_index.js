var documenterSearchIndex = {"docs":
[{"location":"#Mendel-Iterative-Hard-Thresholding-1","page":"Home","title":"Mendel - Iterative Hard Thresholding","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A modern approach to analyze data from a Genome Wide Association Studies (GWAS)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"note: Note\nPlease see the OpenMendel paper for a review of GWAS statistics and why we chose Julia as the programming language for this project. Pay attention to sections Handling SNP data and Iterative hard thresholding because they are especially relevant in this package.","category":"page"},{"location":"#Package-Feature-1","page":"Home","title":"Package Feature","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Analyze large GWAS datasets intuitively.\nBuilt-in parallel computing routines for q-fold cross-validation.\nFits a variety of generalized linear models with any choice of link function.\nComputation directly on raw genotype files.\nAbility to include non-genetic covariates.\nOptional acceleration (debias) step to dramatically improve speed.\nAbility to explicitly incorporate weights for predictors.\nAbility to enforce within and between group sparsity. \nExcellent flexibility to handle different data structures and complements well with other Julia packages.","category":"page"},{"location":"#Manual-Outline-1","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"    pages = [\n\t\t\"Home\"            => \"index.md\",\n        \"Getting Started\" => \"man/getting_started.md\",\n        \"Examples\"        => \"man/examples.md\",\n        \"Contributing\"    => \"man/contributing.md\",\n    ]","category":"page"},{"location":"man/getting_started/#Getting-started-1","page":"Getting Started","title":"Getting started","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"MendelIHT is designed to be user-friendly. In this section, we outline the basic procedure to analyze your GWAS data with MendelIHT. ","category":"page"},{"location":"man/getting_started/#Installation-1","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Press ] to enter package manager mode and type the following (after pkg>):","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"(v1.0) pkg> add https://github.com/OpenMendel/SnpArrays.jl\n(v1.0) pkg> add https://github.com/OpenMendel/MendelSearch.jl\n(v1.0) pkg> add https://github.com/OpenMendel/MendelBase.jl\n(v1.0) pkg> add https://github.com/biona001/MendelIHT.jl","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"The order of installation is important!","category":"page"},{"location":"man/getting_started/#Step-Workflow-1","page":"Getting Started","title":"3 Step Workflow","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Most analysis consists of 3 simple steps:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Import data.\nRun cv_iht to determine best model size.\nRun L0_reg to obtain final model.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"We believe the best way to learn is through examples. Head over to the example section to see these steps in action. Nevertheless, below contains function signatures and use cautions that any users should be aware. ","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"note: Note\n(1) MendelIHT.jl assumes there are NO missing genotypes, and (2) the trios (.bim, .bed, .fam) must all be present in the same directory. ","category":"page"},{"location":"man/getting_started/#Core-Functions-1","page":"Getting Started","title":"Core Functions","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"A standard user should only ever run 2 functions, other than importing data.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"  cv_iht","category":"page"},{"location":"man/getting_started/#MendelIHT.cv_iht","page":"Getting Started","title":"MendelIHT.cv_iht","text":"cv_iht(d, l, x, z, y, J, path, num_fold)\n\nPerforms q-fold cross validation and returns the deviance residuals for each model. \n\nEach CPU runs a different model for a given fold. To use this function, start julia  using 4 (the more the better) processors by:\n\njulia -p 4\n\nArguments\n\nd: A distribution (e.g. Normal, Bernoulli)\nl: A link function (e.g. Loglink, ProbitLink)\nx: A SnpArray, which can be memory mapped to a file. Does not engage in any linear algebra\nz: Matrix of non-genetic covariates. The first column usually denotes the intercept. \ny: Response vector\nJ: The number of maximum groups\npath: Vector storing different model sizes\nnum_fold: Number of cross validation folds. For large data do not set this to be greater than 5\n\nOptional Arguments: \n\ngroup vector storing group membership\nweight vector storing vector of weights containing prior knowledge on each SNP\nfolds: Vector that separates the sample into q disjoint subsets\ninit: Boolean indicating whether we should initialize IHT algorithm at a good starting guess\nuse_maf: Boolean indicating we should scale the projection step by a weight vector \ndebias: Boolean indicating whether we should debias at each IHT step\nshowinfo: Whether we want IHT to print meaningful intermediate steps\nparallel: Whether we want to run cv_iht using multiple CPUs (highly recommended)\n\n\n\n\n\n","category":"function"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"note: Note\nDo not delete intermediate files (e.g. train.bed) which will be created in the current directory when you run cv_iht. These are memory-mapped training/testing files that are necessary to run cross validation. This means that you must have x GB of free space on your hard disk where x is how much memory it takes to store your .bed file.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"  L0_reg","category":"page"},{"location":"man/getting_started/#MendelIHT.L0_reg","page":"Getting Started","title":"MendelIHT.L0_reg","text":"L0_reg(x, xbm, z, y, J, k, d, l)\n\nRuns Iterative Hard Thresholding for GWAS data x, response y, and non-genetic covariates z on a specific sparsity parameter k. \n\nOne needs to construct a SnpBitMatrix type (xbm below) before running this function.\n\nArguments:\n\nx: A SnpArray, which can be memory mapped to a file. Does not engage in any linear algebra\nxbm: The bitarray representation of x. This matrix is loaded in RAM and performs linear algebra. It's possible to set scale=false for xbm, especially when rare SNPs exist\nz: Matrix of non-genetic covariates. The first column usually denotes the intercept. \ny: Response vector\nJ: The number of maximum groups\nk: Number of non-zero predictors in each group\nd: A distribution (e.g. Normal, Poisson)\nl: A link function (e.g. Loglink, ProbitLink)\n\nOptional Arguments: \n\ngroup vector storing group membership\nweight vector storing vector of weights containing prior knowledge on each SNP\nuse_maf indicates whether we want to scale the projection with minor allele frequencies (see paper)\ndebias is boolean indicating whether we debias at each iteration (see paper)\nshow_info boolean indicating whether we want to print results if model does not converge. Should set to false for multithread/multicore computing\ninit boolean indicating whether we want to initialize β to sensible values through fitting. This is not efficient yet. \ntol is used to track convergence\nmax_iter is the maximum IHT iteration for a model to converge. Defaults to 200, or 100 for cross validation\nmax_step is the maximum number of backtracking. Since l0 norm is not convex, we have no ascent guarantee\n\n\n\n\n\n","category":"function"},{"location":"man/getting_started/#Supported-GLM-models-and-Link-functions-1","page":"Getting Started","title":"Supported GLM models and Link functions","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"MendelIHT borrows the distribution and link function implementations in GLM.jl.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Distributions (listed with their canonical link) that work with L0_reg and cv_iht are:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"          Normal (IdentityLink)\n       Bernoulli (LogitLink)\n         Poisson (LogLink)\nNegativeBinomial (LogLink)\n           Gamma (InverseLink) **(not tested)**\n InverseGaussian (InverseSquareLink) **(not tested)**","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Available link functions are:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"CauchitLink\nCloglogLink\nIdentityLink\nInverseLink\nInverseSquareLink\nLogitLink\nLogLink\nProbitLink\nSqrtLink","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"tip: Tip\nFor d = NegativeBinomial or d=Gamma, the link function must be LogLink. For Bernoulli, the ProbitLink seems to work better than LogitLink.","category":"page"},{"location":"man/getting_started/#Specifying-Groups-and-Weights-1","page":"Getting Started","title":"Specifying Groups and Weights","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"When you have group and weight information, you input them as optional arguments in L0_reg and cv_iht. The weight vector is a vector of Float64, while the group vector is a vector of integers. ","category":"page"},{"location":"man/getting_started/#Simulation-utilities-1","page":"Getting Started","title":"Simulation utilities","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"MendelIHT provides some simulation utilities that help users explore the function and capabilities of iterative hard thresholding. ","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"  simulate_random_snparray","category":"page"},{"location":"man/getting_started/#MendelIHT.simulate_random_snparray","page":"Getting Started","title":"MendelIHT.simulate_random_snparray","text":"simulate_random_snparray(n::Integer, p::Integer, s::String; mafs::Vector{Float64}, min_ma::Integer)\n\nCreates a random SnpArray in the current directory without missing value,  where each SNP has ⫺5 (default) minor alleles. \n\nNote: if supplied minor allele frequency is extremely small, it could take a long time for  the simulation to generate samples where at least min_ma (defaults to 5) are present. \n\nArguments:\n\nn: number of samples\np: number of SNPs\ns: name of the simulated SnpArray that will be created on the current directory\n\nOptional Arguments:\n\nmafs: vector of desired minor allele freuqencies\nmin_ma: the minimum number of minor alleles that must be present for each SNP (defaults to 5)\n\n\n\n\n\n","category":"function"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"note: Note\nSimulating a SnpArray with n subjects and p SNPs requires roughly n times p times 4 bits. Make sure you have enough RAM before simulating very large SnpArrays.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"  simulate_random_response","category":"page"},{"location":"man/getting_started/#MendelIHT.simulate_random_response","page":"Getting Started","title":"MendelIHT.simulate_random_response","text":"simulate_random_response(x::SnpArray, xbm::SnpBitMatrix, k::Int, d::UnionAll, l::Link)\n\nThis function simulates a random response (trait) vector y based on provided x, β, distirbution, and link function. \n\nWhen the distribution is from Poisson, Gamma, or Negative Binomial, we simulate β ∼ N(0, 0.3)  to roughly ensure the mean of response y doesn't become too large. For other distributions, we choose β ∼ N(0, 1). \n\n#Arguments\n\nx: The SnpArray\nxbm: SnpBitMatrix type of your SnpArray\nk: the true number of predictors. \nd: The distribution of the simulated trait (note typeof(d) = UnionAll but typeof(d()) is an actual distribution: e.g. Normal)\nl: The link function. Input canonicallink(d()) if you want to use the canonical link of d.\n\nOptional arguments\n\nnn: The number of success until stopping in negative binomial regression, defaults to 10\nα: Shape parameter of the gamma distribution, defaults to 1\n\n\n\n\n\n","category":"function"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"note: Note\nFor negative binomial and gamma, the link function must be LogLink. For Bernoulli, the probit link seems to work better than logitlink when used in cv_iht or L0_reg. ","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"  adhoc_add_correlation","category":"page"},{"location":"man/getting_started/#MendelIHT.adhoc_add_correlation","page":"Getting Started","title":"MendelIHT.adhoc_add_correlation","text":"adhoc_add_correlation(x::SnpArray, ρ::Float64, pos::Int64, location::Vector{Int})\n\nMakes 1 SNP (a column of x) correlate with SNPs in location with correlation coefficient roughly ρ.\n\nArguments:\n\nx: the snparray\nρ: correlation coefficient\npos: the position of the target SNP that everything would be correlated to\nlocation: All the SNPs that shall be correlated with the SNP at position pos with correlation ρ.\n\n\n\n\n\n","category":"function"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"  simulate_rare_variants","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"  make_bim_fam_files","category":"page"},{"location":"man/getting_started/#MendelIHT.make_bim_fam_files","page":"Getting Started","title":"MendelIHT.make_bim_fam_files","text":"make_bim_fam_files(x::SnpArray, y, name::String)\n\nCreates .bim and .bed files from a SnpArray. \n\nArguments: x: A SnpArray (i.e. .bed file on the disk) for which you wish to create corresponding .bim and .fam files. name: string that should match the .bed file (Do not include .bim or .fam extensions in name). y: Trait vector that will go in to the 6th column of .fam file. \n\n\n\n\n\n","category":"function"},{"location":"man/getting_started/#Other-Useful-Functions-1","page":"Getting Started","title":"Other Useful Functions","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"MendelIHT additionally provides useful utilities that may be of interest to a few advanced users. ","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"  iht_run_many_models","category":"page"},{"location":"man/getting_started/#MendelIHT.iht_run_many_models","page":"Getting Started","title":"MendelIHT.iht_run_many_models","text":"Runs IHT across many different model sizes specifed in path. \n\nThis is basically the same as cv_iht except we DO NOT validate each model  in a holdout set, meaning that this will definitely induce overfitting as we increase model size. Use this to perform a quick estimate a range of feasible model sizes before  engaging in full cross validation. \n\n\n\n\n\n","category":"function"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"  loglikelihood","category":"page"},{"location":"man/getting_started/#MendelIHT.loglikelihood","page":"Getting Started","title":"MendelIHT.loglikelihood","text":"loglikelihood(y::AbstractVector, xb::AbstractVector, d::UnivariateDistribution)\n\nThis function calculates the loglikelihood of observing y given μ = g^{-1}(xb). \n\n\n\n\n\n","category":"function"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"  project_k!","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"  project_group_sparse!","category":"page"},{"location":"man/getting_started/#MendelIHT.project_group_sparse!","page":"Getting Started","title":"MendelIHT.project_group_sparse!","text":"project_group_sparse!(y::AbstractVector, group::AbstractVector, J::Integer, k::Integer)\n\nProjects the vector y onto the set with at most J active groups and at most k active predictors per group. The variable group encodes group membership. Currently assumes there are no unknown or overlaping group membership.\n\n\n\n\n\n","category":"function"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"  maf_weights","category":"page"},{"location":"man/getting_started/#MendelIHT.maf_weights","page":"Getting Started","title":"MendelIHT.maf_weights","text":"Calculates the prior weight based on minor allele frequencies. Returns an array  with weights wi = 1 / (2 sqrt(pi (1 - p_i))) ∈ (1, ∞) where p is maf of allele i. \n\n\n\n\n\n","category":"function"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"  initialize_beta!","category":"page"},{"location":"man/examples/#Examples-1","page":"Examples","title":"Examples","text":"","category":"section"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"Here we give numerous example analysis of GWAS data with MendelIHT. ","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"# machine information for reproducibility\nversioninfo()","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"Julia Version 1.0.3\nCommit 099e826241 (2018-12-18 01:34 UTC)\nPlatform Info:\n  OS: macOS (x86_64-apple-darwin14.5.0)\n  CPU: Intel(R) Core(TM) i7-3740QM CPU @ 2.70GHz\n  WORD_SIZE: 64\n  LIBM: libopenlibm\n  LLVM: libLLVM-6.0.0 (ORCJIT, ivybridge)","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"#first add workers needed for parallel computing. Add only as many CPU cores available\nusing Distributed\naddprocs(4)\n\n#load necessary packages for running all examples below\nusing MendelIHT\nusing SnpArrays\nusing DataFrames\nusing Distributions\nusing Random\nusing LinearAlgebra\nusing GLM\nusing DelimitedFiles\nusing Statistics","category":"page"},{"location":"man/examples/#Example-1:-How-to-Import-Data-1","page":"Examples","title":"Example 1: How to Import Data","text":"","category":"section"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"We use SnpArrays.jl as backend to process genotype files. Internally, the genotype file is a memory mapped SnpArray, which will not be loaded into RAM. If you wish to run L0_reg, you need to convert a SnpArray into a SnpBitMatrix, which consumes n times p times 2 bits of RAM. Non-genetic predictors should be read into Julia in the standard way, and should be stored as a matrix of type Float64 (i.e. Array{Float64, 2}. One should include the intercept (typically in the first column), but an intercept is not required to run IHT. ","category":"page"},{"location":"man/examples/#Reading-Genotype-data-and-Non-Genetic-Covariates-1","page":"Examples","title":"Reading Genotype data and Non-Genetic Covariates","text":"","category":"section"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"x   = SnpArray(\"../data/test1.bed\")\nxbm = SnpBitMatrix{Float64}(x, model=ADDITIVE_MODEL, center=true, scale=true);\nz   = readdlm(\"../data/test1_covariates.txt\") # 1st column intercept, 2nd column sex","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"1000×2 Array{Float64,2}:\n 1.0  2.0\n 1.0  1.0\n 1.0  2.0\n 1.0  1.0\n 1.0  1.0\n 1.0  1.0\n 1.0  2.0\n 1.0  1.0\n 1.0  1.0\n 1.0  1.0\n 1.0  1.0\n 1.0  2.0\n 1.0  1.0\n ⋮       \n 1.0  1.0\n 1.0  1.0\n 1.0  1.0\n 1.0  2.0\n 1.0  2.0\n 1.0  2.0\n 1.0  1.0\n 1.0  2.0\n 1.0  1.0\n 1.0  1.0\n 1.0  2.0\n 1.0  1.0","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"@show typeof(x)\n@show typeof(xbm)\n@show typeof(z); #non genetic covariates must be Array{Float64, 2} even if only the intercept is included","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"typeof(x) = SnpArray\ntypeof(xbm) = SnpBitMatrix{Float64}\ntypeof(z) = Array{Float64,2}","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"note: Note\n(1) MendelIHT.jl assumes there are NO missing genotypes, and (2) the trios (.bim, .bed, .fam) must all be present in the same directory. ","category":"page"},{"location":"man/examples/#Standardizing-Non-Genetic-Covariates.-1","page":"Examples","title":"Standardizing Non-Genetic Covariates.","text":"","category":"section"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"We recommend standardizing all genetic and non-genetic covarariates (including binary and categorical), except for the intercept. This ensures equal penalization for all. SnpBitMatrix efficiently achieves this standardization for genotype data, but non-genetic covariates must be done manually, as below:","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"# standardize all covariates (other than intercept) to mean 0 variance 1\nfor i in 2:size(z, 2)\n    col_mean = mean(z[:, i])\n    col_std  = std(z[:, i])\n    z[:, i] .= (z[:, i] .- col_mean) ./ col_std\nend\nz","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"1000×2 Array{Float64,2}:\n 1.0   1.01969 \n 1.0  -0.979706\n 1.0   1.01969 \n 1.0  -0.979706\n 1.0  -0.979706\n 1.0  -0.979706\n 1.0   1.01969 \n 1.0  -0.979706\n 1.0  -0.979706\n 1.0  -0.979706\n 1.0  -0.979706\n 1.0   1.01969 \n 1.0  -0.979706\n ⋮             \n 1.0  -0.979706\n 1.0  -0.979706\n 1.0  -0.979706\n 1.0   1.01969 \n 1.0   1.01969 \n 1.0   1.01969 \n 1.0  -0.979706\n 1.0   1.01969 \n 1.0  -0.979706\n 1.0  -0.979706\n 1.0   1.01969 \n 1.0  -0.979706","category":"page"},{"location":"man/examples/#Example-2:-Quantitative-Traits-1","page":"Examples","title":"Example 2: Quantitative Traits","text":"","category":"section"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"Quantitative traits are continuous phenotypes whose distribution can be modeled by the normal distribution. Then using the genotype matrix mathbfX and phenotype vector mathbfy, we want to recover beta such that mathbfy approx mathbfXbeta. ","category":"page"},{"location":"man/examples/#Step-1:-Import-data-1","page":"Examples","title":"Step 1: Import data","text":"","category":"section"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"In Example 1 we illustrated how to import data into Julia. So here we use simulated data (code) because, only then, can we compare IHT's result to the true solution. Below we simulate a GWAS data with n=1000 patients and p=10000 SNPs. Here the quantitative trait vector are affected by k = 10 causal SNPs, with no non-genetic confounders. ","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"In this example, our model is simulated as: y_i sim mathbfx_i^Tmathbfbeta + epsilon_i x_ij sim Binomial(2 p_j) p_j sim Uniform(0 05) epsilon_i sim N(0 1) beta_i sim N(0 1)","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"# Define model dimensions, true model size, distribution, and link functions\nn = 1000\np = 10000\nk = 10\nd = Normal\nl = canonicallink(d())","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"IdentityLink()","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"# set random seed for reproducibility\nRandom.seed!(2019) \n\n# simulate SNP matrix, store the result in a file called tmp.bed\nx, = simulate_random_snparray(n, p, \"tmp.bed\")\n\n#construct the SnpBitMatrix type (needed for L0_reg() and simulate_random_response() below)\nxbm = SnpBitMatrix{Float64}(x, model=ADDITIVE_MODEL, center=true, scale=true); \n\n# intercept is the only nongenetic covariate\nz = ones(n, 1) \n\n# simulate response y, true model b, and the correct non-0 positions of b\ny, true_b, correct_position = simulate_random_response(x, xbm, k, d, l)","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"([-1.55712, -2.58259, 2.90878, 2.97143, -0.623694, -1.53675, -1.31672, -0.260568, 4.71735, 3.16402  …  1.50775, -7.16653, -2.75505, -0.748213, 0.529417, 0.170073, -2.31786, -0.27737, -1.29737, 3.94419], [0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0], [853, 877, 924, 2703, 4241, 4783, 5094, 5284, 7760, 8255])","category":"page"},{"location":"man/examples/#Step-2:-Run-cross-validation-to-determine-best-model-size-1","page":"Examples","title":"Step 2: Run cross validation to determine best model size","text":"","category":"section"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"To run cv_iht, you must specify path and num_fold, defined below:","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"path are all the model sizes you wish to test, stored in a vector of integers.\nnum_fold indicates how many disjoint partitions of the samples is requested. ","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"By default, we partition the training/testing data randomly, but you can change this by inputing the fold vector as optional argument. In this example we tested k = 1 2  20 across 3 fold cross validation. This is equivalent to running IHT across 60 different models, and hence, is ideal for parallel computing (which you specify by parallel=true). ","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"path = collect(1:20)\nnum_folds = 3","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"3","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"mses = cv_iht(d(), l, x, z, y, 1, path, num_folds, parallel=true); #here 1 is for number of groups","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"Crossvalidation Results:\n\tk\tMSE\n\t1\t1927.0765190526672\n\t2\t1443.8788742220866\n\t3\t1080.041135323195\n\t4\t862.2385953735205\n\t5\t705.1014346627649\n\t6\t507.394935936422\n\t7\t391.9686876462285\n\t8\t368.45440222003174\n\t9\t350.64279409251793\n\t10\t345.8380848576577\n\t11\t350.51881472845776\n\t12\t359.42391568519577\n\t13\t363.7095696959907\n\t14\t377.30732985896975\n\t15\t381.0310879522695\n\t16\t392.5643923838261\n\t17\t396.81166049333797\n\t18\t397.3010019298764\n\t19\t406.47023764639624\n\t20\t410.4672260807978\n\nThe lowest MSE is achieved at k = 10","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"note: Note\ncv_iht() generates intermediate files such as train.tmp. DO NOT remove these files before the algorithm terminate. These are necessary auxiliary files that will be automatically removed when cross validation completes. ","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"tip: Tip\nBecause Julia employs a JIT compiler, the first round of any function call run will always take longer and consume extra memory. Therefore it is advised to always run a small \"test example\" (such as this one!) before running cross validation on a large dataset. ","category":"page"},{"location":"man/examples/#Step-3:-Run-full-model-on-the-best-estimated-model-size-1","page":"Examples","title":"Step 3: Run full model on the best estimated model size","text":"","category":"section"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"According to our cross validation result, the best model size that minimizes deviance residuals (i.e. MSE on the q-th subset of samples) is attained at k = 10. That is, cross validation detected that we need 10 SNPs to achieve the best model size. Using this information, one can re-run the IHT algorithm on the full dataset to obtain the best estimated model.","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"k_est = argmin(mses)\nresult = L0_reg(x, xbm, z, y, 1, k_est, d(), l)","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"IHT results:\n\nCompute time (sec):     0.5330710411071777\nFinal loglikelihood:    -1406.8807653835697\nIterations:             6\nMax number of groups:   1\nMax predictors/group:   10\nIHT estimated 10 nonzero SNP predictors and 0 non-genetic predictors.\n\nSelected genetic predictors:\n10×2 DataFrame\n│ Row │ Position │ Estimated_β │\n│     │ \u001b[90mInt64\u001b[39m    │ \u001b[90mFloat64\u001b[39m     │\n├─────┼──────────┼─────────────┤\n│ 1   │ 853      │ -1.24117    │\n│ 2   │ 877      │ -0.234676   │\n│ 3   │ 924      │ 0.82014     │\n│ 4   │ 2703     │ 0.583403    │\n│ 5   │ 4241     │ 0.298304    │\n│ 6   │ 4783     │ -1.14459    │\n│ 7   │ 5094     │ 0.673012    │\n│ 8   │ 5284     │ -0.709736   │\n│ 9   │ 7760     │ 0.16866     │\n│ 10  │ 8255     │ 1.08117     │\n\nSelected nongenetic predictors:\n0×2 DataFrame","category":"page"},{"location":"man/examples/#Step-4-(only-for-simulated-data):-Check-final-model-against-simulation-1","page":"Examples","title":"Step 4 (only for simulated data): Check final model against simulation","text":"","category":"section"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"Since all our data and model was simulated, we can see how well cv_iht combined with L0_reg estimated the true model. For this example, we find that IHT found every simulated predictor, with 0 false positives. ","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"compare_model = DataFrame(\n    true_β      = true_b[correct_position], \n    estimated_β = result.beta[correct_position])\n@show compare_model\n\n#clean up\nrm(\"tmp.bed\", force=true)","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"compare_model = 10×2 DataFrame\n│ Row │ true_β   │ estimated_β │\n│     │ Float64  │ Float64     │\n├─────┼──────────┼─────────────┤\n│ 1   │ -1.29964 │ -1.24117    │\n│ 2   │ -0.2177  │ -0.234676   │\n│ 3   │ 0.786217 │ 0.82014     │\n│ 4   │ 0.599233 │ 0.583403    │\n│ 5   │ 0.283711 │ 0.298304    │\n│ 6   │ -1.12537 │ -1.14459    │\n│ 7   │ 0.693374 │ 0.673012    │\n│ 8   │ -0.67709 │ -0.709736   │\n│ 9   │ 0.14727  │ 0.16866     │\n│ 10  │ 1.03477  │ 1.08117     │","category":"page"},{"location":"man/examples/#Example-3:-Logistic-Regression-Controlling-for-Sex-1","page":"Examples","title":"Example 3: Logistic Regression Controlling for Sex","text":"","category":"section"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"We show how to use IHT to handle case-control studies. In this example, we fit a logistic regression model with IHT using simulated case-control data, while controling for sex as a non-genetic covariate. ","category":"page"},{"location":"man/examples/#Step-1:-Import-Data-1","page":"Examples","title":"Step 1: Import Data","text":"","category":"section"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"Again we use a simulated model: y_i sim Bernoulli(mathbfx_i^Tmathbfbeta) x_ij sim Binomial(2 p_j) p_j sim Uniform(0 05) beta_i sim N(0 1) beta_intercept = 1 beta_sex = 15","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"We assumed there are k=8 genetic predictors and 2 non-genetic predictors (intercept and sex) that affects the trait. The simulation code in our package does not yet handle simulations with non-genetic predictors, so we must simulate these phenotypes manually. ","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"# Define model dimensions, true model size, distribution, and link functions\nn = 1000\np = 10000\nk = 10\nd = Bernoulli\nl = canonicallink(d())\n\n# set random seed for reproducibility\nRandom.seed!(2019)\n\n# construct SnpArray and SnpBitMatrix\nx, = simulate_random_snparray(n, p, \"tmp.bed\")\nxbm = SnpBitMatrix{Float64}(x, model=ADDITIVE_MODEL, center=true, scale=true);\n\n# nongenetic covariate: first column is the intercept, second column is sex: 0 = male 1 = female\nz = ones(n, 2) \nz[:, 2] .= rand(0:1, n)\n\n# randomly set genetic predictors\ntrue_b = zeros(p) \ntrue_b[1:k-2] = randn(k-2)\nshuffle!(true_b)\n\n# find correct position of genetic predictors\ncorrect_position = findall(!iszero, true_b)\n\n# define effect size of non-genetic predictors: intercept & sex\ntrue_c = [1.0; 1.5] \n\n# simulate phenotype using genetic and nongenetic predictors\nprob = linkinv.(l, xbm * true_b .+ z * true_c)\ny = [rand(d(i)) for i in prob]\ny = Float64.(y) # y must be floating point numbers","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"1000-element Array{Float64,1}:\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 1.0\n 0.0\n 1.0\n 1.0\n 0.0\n ⋮  \n 1.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 0.0\n 1.0\n 1.0\n 1.0\n 0.0\n 1.0","category":"page"},{"location":"man/examples/#Step-2:-Run-cross-validation-to-determine-best-model-size-2","page":"Examples","title":"Step 2: Run cross validation to determine best model size","text":"","category":"section"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"To run cv_iht, you must specify path and num_fold, defined below:","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"path are all the model sizes you wish to test, stored in a vector of integers.\nnum_fold indicates how many disjoint partitions of the samples is requested. ","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"By default, we partition the training/testing data randomly, but you can change this by inputing the fold vector as optional argument. In this example we tested k = 1 2  20 across 3 fold cross validation. This is equivalent to running IHT across 60 different models, and hence, is ideal for parallel computing (which you specify by parallel=true). ","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"path = collect(1:20)\nnum_folds = 3","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"3","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"mses = cv_iht(d(), l, x, z, y, 1, path, num_folds, parallel=true); #here 1 is for number of groups","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"Crossvalidation Results:\n\tk\tMSE\n\t1\t391.44413742296507\n\t2\t365.75172666211597\n\t3\t332.3877206652262\n\t4\t273.2076336536057\n\t5\t238.71565721188784\n\t6\t230.23676864994815\n\t7\t214.8917395180223\n\t8\t199.01560091101322\n\t9\t208.3101897282104\n\t10\t219.82354033490867\n\t11\t230.12560285605036\n\t12\t240.7100189430074\n\t13\t265.89197902031015\n\t14\t272.29213890904106\n\t15\t271.7833424289932\n\t16\t298.34625245932193\n\t17\t317.85972029019524\n\t18\t367.31668485042815\n\t19\t379.8081201465501\n\t20\t407.72418511154956\n\nThe lowest MSE is achieved at k = 8","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"tip: Tip\nTry the optinal input debias=true in cv_iht or L0_reg. This is an acceleration that potentially allows IHT to converge must faster. ","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"tip: Tip\nIn our experience, using the ProbitLink for logistic regressions deliver better results than LogitLink (which is the canonical link). ","category":"page"},{"location":"man/examples/#Step-3:-Run-full-model-on-the-best-estimated-model-size-2","page":"Examples","title":"Step 3: Run full model on the best estimated model size","text":"","category":"section"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"Cross validation have declared that k_best = 8. Using this information, one can re-run the IHT algorithm on the full dataset to obtain the best estimated model.","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"k_est = argmin(mses)\nresult = L0_reg(x, xbm, z, y, 1, k_est, d(), l)","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"IHT results:\n\nCompute time (sec):     1.797137975692749\nFinal loglikelihood:    -290.45093915185475\nIterations:             33\nMax number of groups:   1\nMax predictors/group:   8\nIHT estimated 6 nonzero SNP predictors and 2 non-genetic predictors.\n\nSelected genetic predictors:\n6×2 DataFrame\n│ Row │ Position │ Estimated_β │\n│     │ \u001b[90mInt64\u001b[39m    │ \u001b[90mFloat64\u001b[39m     │\n├─────┼──────────┼─────────────┤\n│ 1   │ 1152     │ 0.96664     │\n│ 2   │ 1576     │ 1.56174     │\n│ 3   │ 3411     │ 0.876702    │\n│ 4   │ 5765     │ -1.75602    │\n│ 5   │ 5992     │ -2.04509    │\n│ 6   │ 8781     │ 0.760146    │\n\nSelected nongenetic predictors:\n2×2 DataFrame\n│ Row │ Position │ Estimated_β │\n│     │ \u001b[90mInt64\u001b[39m    │ \u001b[90mFloat64\u001b[39m     │\n├─────┼──────────┼─────────────┤\n│ 1   │ 1        │ 0.710066    │\n│ 2   │ 2        │ 1.6505      │","category":"page"},{"location":"man/examples/#Step-4-(only-for-simulated-data):-Check-final-model-against-simulation-2","page":"Examples","title":"Step 4 (only for simulated data): Check final model against simulation","text":"","category":"section"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"Since all our data and model was simulated, we can see how well cv_iht combined with L0_reg estimated the true model. For this example, we find that IHT found every simulated predictor, with 0 false positives. ","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"compare_model_genetics = DataFrame(\n    true_β      = true_b[correct_position], \n    estimated_β = result.beta[correct_position])\n\ncompare_model_nongenetics = DataFrame(\n    true_c      = true_c[1:2], \n    estimated_c = result.c[1:2])\n\n@show compare_model_genetics\n@show compare_model_nongenetics\n\n#clean up\nrm(\"tmp.bed\", force=true)","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"compare_model_genetics = 8×2 DataFrame\n│ Row │ true_β   │ estimated_β │\n│     │ Float64  │ Float64     │\n├─────┼──────────┼─────────────┤\n│ 1   │ 0.961937 │ 0.96664     │\n│ 2   │ 0.189267 │ 0.0         │\n│ 3   │ 1.74008  │ 1.56174     │\n│ 4   │ 0.879004 │ 0.876702    │\n│ 5   │ 0.213066 │ 0.0         │\n│ 6   │ -1.74663 │ -1.75602    │\n│ 7   │ -1.93402 │ -2.04509    │\n│ 8   │ 0.632786 │ 0.760146    │\ncompare_model_nongenetics = 2×2 DataFrame\n│ Row │ true_c  │ estimated_c │\n│     │ Float64 │ Float64     │\n├─────┼─────────┼─────────────┤\n│ 1   │ 1.0     │ 0.710066    │\n│ 2   │ 1.5     │ 1.6505      │","category":"page"},{"location":"man/examples/#Other-examples-and-functionalities-1","page":"Examples","title":"Other examples and functionalities","text":"","category":"section"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"We invite users to experiment with additional functionalities. We explored a significant portion of them in our manuscript, with reproducible code. This includes:","category":"page"},{"location":"man/examples/#","page":"Examples","title":"Examples","text":"Modeling some exotic distributions and using noncanonical link functions listed here\nUsing debias=true in both cv_iht and L0_reg to accelerate convergence.\nModeling SNP-SNP or SNP-environment interaction effects by explicitly including them in the nongenetic covariates z.\nDoubly sparse projection (requires group information)\nWeighted projections to favor certain SNPs (requires weight information)","category":"page"},{"location":"man/contributing/#Contributing-1","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"man/contributing/#","page":"Contributing","title":"Contributing","text":"I am one developer. We are a community. ","category":"page"},{"location":"man/contributing/#","page":"Contributing","title":"Contributing","text":"If you would like to contribute to this project, we compiled a list of desired features for this project. Developers of any level is welcomed. Do not be shy because it can't hurt to ask.","category":"page"},{"location":"man/contributing/#Bug-Fixes-and-User-Support-1","page":"Contributing","title":"Bug Fixes & User Support","text":"","category":"section"},{"location":"man/contributing/#","page":"Contributing","title":"Contributing","text":"If you encounter a bug or you need some user support, please open a new issue here. If you can, provide the error message and, ideally, a reproducible code that generated the error.","category":"page"}]
}
