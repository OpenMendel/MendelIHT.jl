var documenterSearchIndex = {"docs":
[{"location":"#Iterative-Hard-Thresholding-1","page":"Home","title":"Iterative Hard Thresholding","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"A modern approach to analyze data from a Genome Wide Association Studies (GWAS)","category":"page"},{"location":"#","page":"Home","title":"Home","text":"note: Note\nPlease see the OpenMendel paper for a review of GWAS statistics and why we chose Julia as the programming language for this project. Pay attention to sections Handling SNP data and Iterative hard thresholding because they are especially relevant in this package.","category":"page"},{"location":"#Package-Feature-1","page":"Home","title":"Package Feature","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"Analyze large GWAS datasets intuitively.\nAutomatically distributed (parallel) q-fold cross-validation routines.\nAbility to fit a large range of generalized linear models with any choice of link function.\nComputation directly on raw genotype files.\nAbility to include non-genetic covariates.\nOptional acceleration step to dramatically improve speed by setting debias = true.\nAbility to incorporate prior weights for predictors.\nAbility to enforce within and between group sparsity. \nEasily adjustable convergence criteria, max iteration count, and max backtracking.","category":"page"},{"location":"#Manual-Outline-1","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"#","page":"Home","title":"Home","text":"    pages = [\n\t\t\"Home\" => \"index.md\"\n        \"Getting Started\" => \"man/getting_started.md\"\n    ]","category":"page"},{"location":"man/getting_started/#Getting-started-1","page":"Getting Started","title":"Getting started","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"MendelIHT is designed to be user-friendly. In this section, we outline the basic procedure to analyze your GWAS data with MendelIHT. ","category":"page"},{"location":"man/getting_started/#Installation-1","page":"Getting Started","title":"Installation","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Press ] to enter package manager mode and type the following (after pkg>):","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"(v1.0) pkg> add https://github.com/OpenMendel/SnpArrays.jl\n(v1.0) pkg> add https://github.com/OpenMendel/MendelSearch.jl\n(v1.0) pkg> add https://github.com/OpenMendel/MendelBase.jl\n(v1.0) pkg> add https://github.com/biona001/MendelIHT.jl","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"The order of installation is important!","category":"page"},{"location":"man/getting_started/#Step-Workflow-1","page":"Getting Started","title":"3 Step Workflow","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Most analysis consists of 3 simple steps:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Import data.\nRun cv_iht to determine best model size.\nRun L0_reg to obtain final model.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"We believe the best way to learn is through examples. Head over to the example section to see these steps in action. Nevertheless, below contains function signatures and use cautions that any users should be aware. ","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"note: Note\n(1) MendelIHT.jl assumes there are NO missing genotypes, and (2) the trios (.bim, .bed, .fam) must all be present in the same directory. ","category":"page"},{"location":"man/getting_started/#Core-Functions-1","page":"Getting Started","title":"Core Functions","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"A standard user should only ever run 2 functions, other than importing data.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"  cv_iht","category":"page"},{"location":"man/getting_started/#MendelIHT.cv_iht","page":"Getting Started","title":"MendelIHT.cv_iht","text":"This function performs q-fold cross validation for Iterative hard thresholding to determine  the best model size k. Each CPU runs a different model for a given fold. \n\nTo use this function, start julia using 4 (the more the better) processors by\n\njulia -p 4\n\n#Arguments\n\nd: A distribution (e.g. Normal, Poisson)\nl: A link function (e.g. Loglink, ProbitLink)\nx: A SnpArray\nz: Matrix of non-genetic covariates. The first column is treated as integer. \ny: Response vector\nJ: The number of maximum groups\npath: Vector storing different model sizes\nnum_fold: Number of cross validation folds. For large data do not set this to be greater than 5\nfolds: Vector that separates the sample into q disjoint subsets\ninit: Boolean indicating whether we should initialize IHT algorithm at a good starting guess\nuse_maf: Boolean indicating we should scale the projection step by a weight vector \ndebias: Boolean indicating whether we should debias at each IHT step\nshowinfo: Whether we want IHT to print meaningful intermediate steps\nparallel: Whether we want to run cv_iht using multiple CPUs (highly recommended)\n\n\n\n\n\n","category":"function"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"note: Note\nDo not delete intermediate files (e.g. train.bed) which will be created in the current directory when you run cv_iht. These are memory-mapped training/testing files that are necessary to run cross validation. This means that you must have x GB of free space on your hard disk where x is how much memory it takes to store your .bed file.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"  L0_reg","category":"page"},{"location":"man/getting_started/#MendelIHT.L0_reg","page":"Getting Started","title":"MendelIHT.L0_reg","text":"Runs Iterative Hard Thresholding for GWAS data x, response y, and non-genetic covariates z on a specific sparsity parameter k. \n\nOne needs to construct a SnpBitMatrix type (xbm below) before running this function.\n\n#Arguments\n\nx is a SnpArray, which can be memory mapped to a file. Does not engage in any linear algebra\nxbm is the bitarray representation of x. This matrix is loaded in RAM and performs linear algebra. It's possible to set scale=false for xbm, especially when rare SNPs exist\nz Matrix of non-genetic covariates. The first column is treated as integer. \ny Response vector\nJ The number of maximum groups\nk Number of non-zero predictors in each group\nd is a distribution in the exponential family we are fitting to\nl stores the link function. \ngroup vector storing group membership\nweight vector storing vector of weights containing prior knowledge on each SNP\nuse_maf indicates whether we want to scale the projection with minor allele frequencies (see paper)\ndebias is boolean indicating whether we debias at each iteration (see paper)\nshow_info boolean indicating whether we want to print results if model does not converge. Should set to false for multithread/multicore computing\ninit boolean indicating whether we want to initialize β to sensible values through fitting. This is not efficient yet. \ntol is used to track convergence\nmax_iter is the maximum IHT iteration for a model to converge. Defaults to 200, or 100 for cross validation\nmax_step is the maximum number of backtracking. Since l0 norm is not convex, we have no ascent guarantee\n\n\n\n\n\n","category":"function"},{"location":"man/getting_started/#Supported-GLM-models-and-Link-functions-1","page":"Getting Started","title":"Supported GLM models and Link functions","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"MendelIHT borrows the distribution and link function implementations in GLM.jl.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Distributions (listed with their canonical link) that work with L0_reg and cv_iht are:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"          Normal (IdentityLink)\n       Bernoulli (LogitLink)\n         Poisson (LogLink)\nNegativeBinomial (LogLink)\n           Gamma (InverseLink) **(not tested)**\n InverseGaussian (InverseSquareLink) **(not tested)**","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"Available link functions are:","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"CauchitLink\nCloglogLink\nIdentityLink\nInverseLink\nInverseSquareLink\nLogitLink\nLogLink\nProbitLink\nSqrtLink","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"tip: Tip\nFor d = NegativeBinomial or d=Gamma, the link function must be LogLink. For Bernoulli, the ProbitLink seems to work better than LogitLink.","category":"page"},{"location":"man/getting_started/#Specifying-Groups-and-Weights-1","page":"Getting Started","title":"Specifying Groups and Weights","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"When you have group and weight information, you input them as optional arguments in L0_reg and cv_iht. The weight vector is a vector of Float64, while the group vector is a vector of integers. ","category":"page"},{"location":"man/getting_started/#Simulation-utilities-1","page":"Getting Started","title":"Simulation utilities","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"MendelIHT provides some simulation utilities that help users explore the function and capabilities of iterative hard thresholding. ","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"  simulate_random_snparray","category":"page"},{"location":"man/getting_started/#MendelIHT.simulate_random_snparray","page":"Getting Started","title":"MendelIHT.simulate_random_snparray","text":"simulate_random_snparray(n::Integer, p::Integer, s::String; mafs::Vector{Float64}, min_ma::Integer)\n\nCreates a random SnpArray in the current directory without missing value,  where each SNP has ⫺5 (default) minor alleles. \n\n#Arguments n = number of samples p = number of SNPs s = name of the simulated SnpArray that will be created on the current directory\n\n#Optional Arguments mafs = vector of minor allele freuqencies min_ma = the minimum number of minor alleles that must be present for each SNP (defaults to 5)\n\nNote: if supplied minor allele frequency is extremely small, it could take a long time for  the simulation to generate samples where at least min_ma (defaults to 5) are present. \n\n\n\n\n\n","category":"function"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"note: Note\nSimulating a SnpArray with n subjects and p SNPs requires roughly n times p times 4 bits. Make sure you have enough RAM before simulating very large SnpArrays.","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"  simulate_random_response","category":"page"},{"location":"man/getting_started/#MendelIHT.simulate_random_response","page":"Getting Started","title":"MendelIHT.simulate_random_response","text":"simulate_random_response(x::SnpArray, xbm::SnpBitMatrix, k::Int, d::UnionAll, l::Link)\n\nThis function simulates a random response (trait) vector y based on provided x, β, distirbution, and link function. \n\nWhen the distribution is from Poisson, Gamma, or Negative Binomial, we simulate β ∼ N(0, 0.3)  to roughly ensure the mean of response y doesn't become too large. For other distributions, we choose β ∼ N(0, 1). \n\n#Arguments\n\nx: The SnpArray\nxbm: SnpBitMatrix type of your SnpArray\nk: the true number of predictors. \nd: The distribution of the simulatedtrait\nl: The link function. Input canonicallink(d()) if you want to use the canonical link of d.\n\nOptional arguments\n\nnn: The number of success until stopping in negative binomial regression, defaults to 10\nα: Shape parameter of the gamma distribution, defaults to 1\n\n\n\n\n\n","category":"function"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"note: Note\nFor negative binomial and gamma, the link function must be LogLink. For Bernoulli, the probit link seems to work better than logitlink when used in cv_iht or L0_reg. ","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"  adhoc_add_correlation","category":"page"},{"location":"man/getting_started/#MendelIHT.adhoc_add_correlation","page":"Getting Started","title":"MendelIHT.adhoc_add_correlation","text":"Makes some columns of x (i.e. SNPs) correlated with other columns in some ad-hoc way.\n\n#Arguments\n\nx the snparray\nρ correlation coefficient\npos the position of the target SNP that everything would be correlated to\nnum even integer: how many columns of x would be made correlated\nincrement how far should each correlated SNP be located than the one specified in pos.\n\n\n\n\n\n","category":"function"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"  simulate_rare_variants","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"  make_bim_fam_files","category":"page"},{"location":"man/getting_started/#MendelIHT.make_bim_fam_files","page":"Getting Started","title":"MendelIHT.make_bim_fam_files","text":"make_bim_fam_files(x::SnpArray, y, name::String)\n\nCreates .bim and .bed files from a SnpArray. \n\nname is a string that should match the .bed file you simulate with  simulate_random_snparray. Do not include .bim or .fam extensions in name.\n\n\n\n\n\n","category":"function"},{"location":"man/getting_started/#Other-Useful-Functions-1","page":"Getting Started","title":"Other Useful Functions","text":"","category":"section"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"MendelIHT additionally provides useful utilities that may be of interest to a few advanced users. ","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"  iht_run_many_models","category":"page"},{"location":"man/getting_started/#MendelIHT.iht_run_many_models","page":"Getting Started","title":"MendelIHT.iht_run_many_models","text":"Runs IHT across many different model sizes specifed in path. \n\nThis is basically the same as cv_iht except we DO NOT validate each model  in a holdout set, meaning that this will definitely induce overfitting as we increase model size. Use this to perform a quick estimate a range of feasible model sizes before  engaging in full cross validation. \n\n\n\n\n\n","category":"function"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"  loglikelihood","category":"page"},{"location":"man/getting_started/#MendelIHT.loglikelihood","page":"Getting Started","title":"MendelIHT.loglikelihood","text":"loglikelihood(y::AbstractVector, xb::AbstractVector, d::UnivariateDistribution)\n\nThis function calculates the loglikelihood of observing y given μ = g^{-1}(xb). \n\n\n\n\n\n","category":"function"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"  project_k!","category":"page"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"  project_group_sparse!","category":"page"},{"location":"man/getting_started/#MendelIHT.project_group_sparse!","page":"Getting Started","title":"MendelIHT.project_group_sparse!","text":"project_group_sparse!(y::AbstractVector, group::AbstractVector, J::Integer, k::Integer)\n\nProjects the vector y onto the set with at most J active groups and at most k active predictors per group. The variable group encodes group membership. Currently assumes there are no unknown or overlaping group membership.\n\n\n\n\n\n","category":"function"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"  maf_weights","category":"page"},{"location":"man/getting_started/#MendelIHT.maf_weights","page":"Getting Started","title":"MendelIHT.maf_weights","text":"Calculates the prior weight based on minor allele frequencies. Returns an array  with weights wi = 1 / (2 sqrt(pi (1 - p_i))) ∈ (1, ∞) where p is maf of allele i. \n\n\n\n\n\n","category":"function"},{"location":"man/getting_started/#","page":"Getting Started","title":"Getting Started","text":"  initialize_beta!","category":"page"}]
}
